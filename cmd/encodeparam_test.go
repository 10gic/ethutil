package cmd

import (
	"encoding/hex"
	"reflect"
	"testing"
)

func hex2byteArray(hexStr string) []byte {
	data, err := hex.DecodeString(hexStr)
	if err != nil {
		panic(err)
	}
	return data
}

func TestEncodeParameters(t *testing.T) {
	tests := []struct {
		input1 []string
		input2 []string
		want   []byte
	}{
		{
			input1: []string{"uint256"},
			input2: []string{"2"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000002"),
		},
		{
			input1: []string{"bool"},
			input2: []string{"true"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000001"),
		},
		{
			input1: []string{"bool"},
			input2: []string{"false"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"address"},
			input2: []string{"0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb"},
			want:   hex2byteArray("0000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb"),
		},
		{
			input1: []string{"bytes17", "bytes18"},
			input2: []string{"0x1234", "0x5678"},
			want:   hex2byteArray("12340000000000000000000000000000000000000000000000000000000000005678000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"uint256", "address", "bool"},
			input2: []string{"123", "0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb", "true"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000007b0000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb0000000000000000000000000000000000000000000000000000000000000001"),
		},
		{
			input1: []string{"string[]"},
			input2: []string{"[abc,def]"},
			want:   hex2byteArray("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003616263000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036465660000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"string[2]"},
			input2: []string{"[abc,def]"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000003616263000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036465660000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"int8[]"},
			input2: []string{"[15,16]"},
			want:   hex2byteArray("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000010"),
		},
		{
			input1: []string{"int8[2]"},
			input2: []string{"[15,16]"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000010"),
		},
		{
			input1: []string{"int256[]"},
			input2: []string{"[15,16]"},
			want:   hex2byteArray("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000010"),
		},
		{
			input1: []string{"int256[2]"},
			input2: []string{"[15,16]"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000010"),
		},
		{
			input1: []string{"bool[]"},
			input2: []string{"[true,false]"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"bool[2]"},
			input2: []string{"[true,false]"},
			want:   hex2byteArray("00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"address[]"},
			input2: []string{"[0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb,0x02d90F386A47a8Bec2c6aB78148e83771E8e3200]"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb00000000000000000000000002d90f386a47a8bec2c6ab78148e83771e8e3200"),
		},
		{
			input1: []string{"address[2]"},
			input2: []string{"[0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb,0x02d90F386A47a8Bec2c6aB78148e83771E8e3200]"},
			want:   hex2byteArray("0000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb00000000000000000000000002d90f386a47a8bec2c6ab78148e83771e8e3200"),
		},
		{
			input1: []string{"bytes[]"},
			input2: []string{"[0x1122,0x3344]"},
			want:   hex2byteArray("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002112200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000023344000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"bytes[2]"},
			input2: []string{"[0x1122,0x3344]"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000002112200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000023344000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"bytes1[]"},
			input2: []string{"[0x11,0x12]"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000211000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"bytes1[2]"},
			input2: []string{"[0x11,0x12]"},
			want:   hex2byteArray("11000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"bytes32[]"},
			input2: []string{"[0x7f9deddf2c94ab461833c4f873c7ec05320deb5df9fd13230ff85b31734ae7c4,0x4198a79e0d3209486628f06365c48e001bd820edf73572966080ad75ffb59937]"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000027f9deddf2c94ab461833c4f873c7ec05320deb5df9fd13230ff85b31734ae7c44198a79e0d3209486628f06365c48e001bd820edf73572966080ad75ffb59937"),
		},
		{
			input1: []string{"bytes32[2]"},
			input2: []string{"[0x7f9deddf2c94ab461833c4f873c7ec05320deb5df9fd13230ff85b31734ae7c4,0x4198a79e0d3209486628f06365c48e001bd820edf73572966080ad75ffb59937]"},
			want:   hex2byteArray("7f9deddf2c94ab461833c4f873c7ec05320deb5df9fd13230ff85b31734ae7c44198a79e0d3209486628f06365c48e001bd820edf73572966080ad75ffb59937"),
		},
		//// FIXME: multi dimensional array is currently not supported
		//{
		//	input1: []string{"uint256[][]"},
		//	input2: []string{"[[12,13],[14,15]]"},
		//	want:   hex2byteArray("00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000f"),
		//},
		//{
		//	input1: []string{"uint256[3][2]"},
		//	input2: []string{"[[12,13,14],[15,16,17]]"},
		//	want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000f00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000011"),
		//},
		{
			input1: []string{"uint256", "address[]", "bool"},
			input2: []string{"123", "[0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb, 0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb]", "true"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000007b0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb0000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb"),
		},
		{
			input1: []string{"uint256", "address[2]", "bool"},
			input2: []string{"123", "[0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb, 0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb]", "true"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000007b0000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb0000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb0000000000000000000000000000000000000000000000000000000000000001"),
		},
		{
			input1: []string{"(uint256, bool)"}, // Solidity struct (Abi tuple)
			input2: []string{"(30, true)"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000001"),
		},
		{
			input1: []string{"(uint256, bool)", "address"}, // Solidity struct (Abi tuple)
			input2: []string{"(30, false)", "0x8F36975cdeA2e6E64f85719788C8EFBBe89DFBbb"},
			want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000008f36975cdea2e6e64f85719788c8efbbe89dfbbb"),
		},
		{
			input1: []string{"(uint256, bool)[]", "uint256"}, // Dynamic array of tuple
			input2: []string{"[(4, true), (5, false)]", "15"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000f00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000"),
		},
		{
			input1: []string{"(uint256, bool)[2]", "uint256"}, // Static size array of tuple
			input2: []string{"[(4, true), (5, false)]", "15"},
			want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f"),
		},
		//// FIXME: The case where the tuple element type is an array is currently not supported
		//{
		//	input1: []string{"(uint256, bool[])", "uint256"},
		//	input2: []string{"(8,[true,false])", "15"},
		//	want:   hex2byteArray("0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000f00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000"),
		//},
		//{
		//	input1: []string{"(uint256, bool[2])", "uint256"},
		//	input2: []string{"(8,[true,false])", "15"},
		//	want:   hex2byteArray("000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f"),
		//},
	}

	for i, tc := range tests {
		got, _ := encodeParameters(tc.input1, tc.input2)
		if !reflect.DeepEqual(tc.want, got) {
			// fmt.Printf("%v", hex.EncodeToString(got))
			t.Fatalf("test %d: expected: %v, got: %v", i+1, tc.want, got)
		}
	}
}

func TestScientificNotation2Decimal(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{
			input: "1e18",
			want:  "1000000000000000000",
		},
		{
			input: "1.0e18",
			want:  "1000000000000000000",
		},
		{
			input: "2e18",
			want:  "2000000000000000000",
		},
		{
			input: "2.0e18",
			want:  "2000000000000000000",
		},
		{
			input: "1.1e5",
			want:  "110000",
		},
		{
			input: "0.1e5",
			want:  "10000",
		},
		{
			input: ".1e5",
			want:  "10000",
		},
	}

	for i, tc := range tests {
		got, _ := scientificNotation2Decimal(tc.input)
		if !reflect.DeepEqual(tc.want, got) {
			// fmt.Printf("%v", hex.EncodeToString(got))
			t.Fatalf("test %d: expected: %v, got: %v", i+1, tc.want, got)
		}
	}
}

func TestParseFuncSignature(t *testing.T) {
	tests := []struct {
		input    string
		wantFn   string
		wantArgs []string
	}{
		{
			input:    "function fn1((uint256, address), bool)",
			wantFn:   "fn1",
			wantArgs: []string{"(uint256, address)", "bool"},
		},
		{
			input:    "function fn1((uint256, address), bool) returns (address)",
			wantFn:   "fn1",
			wantArgs: []string{"(uint256, address)", "bool"},
		},
		{
			input:    "f1(bool[] a, uint256)",
			wantFn:   "f1",
			wantArgs: []string{"bool[]", "uint256"},
		},
		{
			input:    "f1(address payable[] memory a, uint256 b)",
			wantFn:   "f1",
			wantArgs: []string{"address[]", "uint256"},
		},
		{
			input:    "f1(bytes calldata targetCallData, uint256 b)",
			wantFn:   "f1",
			wantArgs: []string{"bytes", "uint256"},
		},
		{
			input:    "function f2((address, bool)[], address payable b)",
			wantFn:   "f2",
			wantArgs: []string{"(address, bool)[]", "address"},
		},
		//// FIXME: array argument with name is currently not supported
		//{
		//	input:    "function f2((address, bool)[] calldata ops, address payable b)",
		//	wantFn:   "f2",
		//	wantArgs: []string{"(address, bool)[]", "address"},
		//},
	}

	for i, tc := range tests {
		gotFn, gotArgs, _ := parseFuncSignature(tc.input)
		if !reflect.DeepEqual(tc.wantFn, gotFn) {
			// fmt.Printf("%v", hex.EncodeToString(got))
			t.Fatalf("test %d: expected: %v, got: %v", i+1, tc.wantFn, gotFn)
		}
		if !reflect.DeepEqual(tc.wantArgs, gotArgs) {
			// fmt.Printf("%v", hex.EncodeToString(got))
			t.Fatalf("test %d: expected: %v, got: %v", i+1, tc.wantArgs, gotArgs)
		}
	}
}
